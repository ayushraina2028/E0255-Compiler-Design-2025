alloca -> automatic allocation
i,j are loaded from memory, this program is still is SSA form without \phi because it is stored in memory. No variable is defined twice, instead changes are directly done in memory.
z = \phi -> becomes store z = \phi 

Now when we convert it to SSA, it will use registers instead of memory
Mem2Reg - LLvM : Learn about this (clang -S -emit-llvm code1.c -o code1.ll | opt -passes='mem2reg' code1.ll -S -o -)

opt -passes='mem2reg' code1.ll -S -o - (use this command to use mem2reg pass)
We can directly use (clang )
Make sure to remove optnone from test.ll file 
Now loop variables are in registers, not in memory 
Now in output we can see phi nodes eg (%.01 = phi i32 [0, %2], [%18, %17]) - means 0 is coming from block 2

All the passes will take input this IR (From mem2reg). Final optimizations will be performed on this one.
One more optimized IR can be generated by (opt -O3 code1.ll -S -o -). IN generated IR, we can all basic blocks are gone and optimization is done

Learn about alloc, alloca, load, store etc.
%10 = alloca [100 * 32], align 16 (this is an instruction to align 16 bytes) (check this !!)
Things that start % are SSA values

sext -> sign extention 
use llvm langref to understand the terminologies in IR (look langref get element ptr)




